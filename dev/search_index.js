var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API reference","title":"API reference","text":"CurrentModule = StreetCars","category":"page"},{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [StreetCars, HashCode2014]","category":"page"},{"location":"api/#StreetCars.StreetCars","page":"API reference","title":"StreetCars.StreetCars","text":"StreetCars\n\nPackage designed to interact with the data of the 2014 Google Hash Code Project\n\n\n\n\n\n","category":"module"},{"location":"api/#StreetCars.RouteGrid","page":"API reference","title":"StreetCars.RouteGrid","text":"RouteGrid\n\nA immutable custom type that stores both a HashCode2014 City along with a set of streets that have been seen by street cars that are  exploring that City.\n\nFields\n\ncity::City: the HashCode2014 City instance that represents the current problem\nseen_streets::Set{Int}: the set of streets that have been seen\n\n\n\n\n\n","category":"type"},{"location":"api/#StreetCars.add_street_to_seen-Tuple{RouteGrid, Int64}","page":"API reference","title":"StreetCars.add_street_to_seen","text":"add_street_to_seen(rg, street)\n\nAdd the given street to the set of seen streets in the given RouteGrid.\n\n\n\n\n\n","category":"method"},{"location":"api/#StreetCars.change_duration-Tuple{RouteGrid, Any}","page":"API reference","title":"StreetCars.change_duration","text":"change_duration(rg, total_duration)\n\nCreate and returns a new RouteGrid with the specified total_duration. All other fields should be the same as the given RouteGrid rg.\n\n\n\n\n\n","category":"method"},{"location":"api/#StreetCars.directed_random_walk-Tuple{Random.AbstractRNG, City}","page":"API reference","title":"StreetCars.directed_random_walk","text":"directed_random_walk(rng, city)\ndirected_random_walk(city)\n\nCreate a solution from a City by letting each car follow a random walk from its starting point.  Bias is given to streets that have not been seen yet.\n\n\n\n\n\n","category":"method"},{"location":"api/#StreetCars.directed_random_walk-Tuple{RouteGrid}","page":"API reference","title":"StreetCars.directed_random_walk","text":"random_walk(rg)\n\nCreate a solution from a RouteGrid by letting each car follow a random walk from its starting point.  Calls generic_walk with a search function that chooses a random candidate.\n\n\n\n\n\n","category":"method"},{"location":"api/#StreetCars.generic_walk-Tuple{RouteGrid, Any}","page":"API reference","title":"StreetCars.generic_walk","text":"generic_walk(rg, search_function)\n\nCreate a solution from a RouteGrid by letting each car follow a walk from its starting point given a search function. The search function should take in an array of candidates and return a tuple of the index of the chosen candidate and the candidate itself.\n\nThe walk algorithm works as follows:\n\nInitialize the itinerary of each car to be a list containing only the starting junction.\nWhile there are still streets that can be explored for a current car:  a. Get the current junction of the car.  b. Get the candidates and unseen candidates for the next street to take.  c. If there are no unseen candidates, then use the seen candidates. If there are no seen candidates, then break out of the loop.  d. Use the search function to choose the next street to take.  e. Add the chosen street to the itinerary of the car.  f. Add the chosen street to the set of seen streets.\n\n\n\n\n\n","category":"method"},{"location":"api/#StreetCars.get_seen_and_unseen_canditates-Tuple{RouteGrid, Int64, Int64}","page":"API reference","title":"StreetCars.get_seen_and_unseen_canditates","text":"get_seen_and_unseen_canditates(rg, current_junction, duration)\n\nGiven a RouteGrid rg, a current junction current_junction, and a duration duration,  return a tuple of two arrays of tuples. The first array contains all the candidates for the next street to take in a city.  A candidate is any street that starts at the current junction and whose duration does not exceed the total duration of the city.  The second returned array contains all of the candidates streets that have not been seen in rg.\n\n\n\n\n\n","category":"method"},{"location":"api/#StreetCars.upper_bound-Tuple{RouteGrid}","page":"API reference","title":"StreetCars.upper_bound","text":"upper_bound(rg)\n\nEstimates the upper bound on the total distance that can be covered by 8 cars for a given RouteGrid. Note that the RouteGrid includes the total duration, the number of cars, the starting junction, and the streets.\n\nThe method involves sorting the RouteGrid City's streets by their distance to duration ratio and then greedily choosing the streets that have the greatest ratio until the total duration of the city is reached. Note that since we have 8 cars, we can  consider the total duration to be 8 times the duration of the city.\n\nThis algorithm provides us a good upper bound becuase we are guaranteed that the most \"efficient\" streets are accounted for when defining the upper bound distance. This upper bound algorithm can impact our final solution  quality in the sense that we can build the intuition that cars should select roads with larger distance to duration ratios if possible.\n\n\n\n\n\n","category":"method"},{"location":"api/#HashCode2014.HashCode2014","page":"API reference","title":"HashCode2014.HashCode2014","text":"HashCode2014\n\nLightweight package designed to interact with the data of the 2014 Google Hash Code.\n\nChallenge description: https://storage.googleapis.com/coding-competitions.appspot.com/HC/2014/hashcode2014_final_task.pdf\n\nChallenge data: https://storage.googleapis.com/coding-competitions.appspot.com/HC/2014/paris_54000.txt\n\nMade for MIT course C25: Julia: Solving Real-World Problems with Computation\n\n\n\n\n\n","category":"module"},{"location":"api/#HashCode2014.City","page":"API reference","title":"HashCode2014.City","text":"City\n\nStore a city made of Junctions and Streets, along with additional instance parameters.\n\nFields\n\ntotal_duration::Int: total time allotted for the car itineraries (in seconds)\nnb_cars::Int: number of cars in the fleet\nstarting_junction::Int: junction at which all the cars are located initially\njunctions::Vector{Junction}: list of junctions\nstreets::Vector{Street}: list of streets\n\n\n\n\n\n","category":"type"},{"location":"api/#HashCode2014.Junction","page":"API reference","title":"HashCode2014.Junction","text":"Junction\n\nStore a city junction.\n\nFields\n\nlatitude::Float64: latitude (in decimal degrees)\nlongitude::Float64: longitude (in decimal degrees)\n\n\n\n\n\n","category":"type"},{"location":"api/#HashCode2014.Solution","page":"API reference","title":"HashCode2014.Solution","text":"Solution\n\nStore a set of itineraries, one for each car.\n\nFields\n\nitineraries::Vector{Vector{Int}}: each itinerary is a vector of junction indices\n\n\n\n\n\n","category":"type"},{"location":"api/#HashCode2014.Street","page":"API reference","title":"HashCode2014.Street","text":"Street\n\nStore an edge between two Junctions.\n\nFields\n\nendpointA::Int: index of the first junction\nendpointB::Int: index of the second junction\nbidirectional::Bool: whether B -> A is allowed\nduration::Int: time cost of traversing the street (in seconds)\ndistance::Int: length of the street (in meters)\n\n\n\n\n\n","category":"type"},{"location":"api/#HashCode2014.get_street_end-Tuple{Integer, Street}","page":"API reference","title":"HashCode2014.get_street_end","text":"get_street_end(i, street)\n\nRetrieve the arrival endpoint of street when it starts at junction i.\n\n\n\n\n\n","category":"method"},{"location":"api/#HashCode2014.is_feasible-Tuple{Solution, City}","page":"API reference","title":"HashCode2014.is_feasible","text":"is_feasible(solution, city[; verbose=false])\n\nCheck if solution satisfies the constraints for the instance defined by city. The following criteria are considered (taken from the problem statement):\n\nthe number of itineraries has to match the number of cars of city\nthe first junction of each itinerary has to be the starting junction of city\nfor each consecutive pair of junctions on an itinerary, a street connecting these junctions has to exist in city (if the street is one directional, it has to be traversed in the correct direction)\nthe duration of each itinerary has to be lower or equal to the total duration of city\n\n\n\n\n\n","category":"method"},{"location":"api/#HashCode2014.is_street-Tuple{Integer, Integer, Street}","page":"API reference","title":"HashCode2014.is_street","text":"is_street(i, j, street)\n\nCheck if the trip from junction i to junction j corresponds to a valid direction of street.\n\n\n\n\n\n","category":"method"},{"location":"api/#HashCode2014.is_street_start-Tuple{Integer, Street}","page":"API reference","title":"HashCode2014.is_street_start","text":"is_street_start(i, street)\n\nCheck if junction i corresponds to a valid starting point of street.\n\n\n\n\n\n","category":"method"},{"location":"api/#HashCode2014.plot_streets","page":"API reference","title":"HashCode2014.plot_streets","text":"plot_streets(city, solution=nothing; path=nothing)\n\nPlot a City and an optional Solution using the Python library folium, save the result as an HTML file at path.\n\n\n\n\n\n","category":"function"},{"location":"api/#HashCode2014.read_city","page":"API reference","title":"HashCode2014.read_city","text":"read_city(path)\n\nRead and parse a City from a file located at path.\n\nThe default path is an artifact containing the official challenge data.\n\n\n\n\n\n","category":"function"},{"location":"api/#HashCode2014.read_solution-Tuple{Any}","page":"API reference","title":"HashCode2014.read_solution","text":"read_solution(solution, path)\n\nRead and parse a Solution from a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/#HashCode2014.total_distance-Tuple{Solution, City}","page":"API reference","title":"HashCode2014.total_distance","text":"total_distance(solution, city)\n\nCompute the total distance of all itineraries in solution based on the street data from city. Streets visited several times are only counted once.\n\n\n\n\n\n","category":"method"},{"location":"api/#HashCode2014.write_city-Tuple{City, Any}","page":"API reference","title":"HashCode2014.write_city","text":"write_city(city, path)\n\nWrite a City to a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/#HashCode2014.write_solution-Tuple{Solution, Any}","page":"API reference","title":"HashCode2014.write_solution","text":"write_solution(solution, path)\n\nWrite a Solution to a file located at path.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"#StreetCars","page":"Home","title":"StreetCars","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for StreetCars. StreetCars builds upon Guillaume Dalle's HashCode2014.jl package to provide a Julia interface for the Google Hash Code 2014 problem, and uses many of the same functions and data structures. Guillaume's package is available at here.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Getting-started","page":"Tutorial","title":"Getting started","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package is not registered. You need to install it from the GitHub repo with","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\nPkg.add(url=\"https://github.com/zakzo1212/StreetCars.jl.git\")","category":"page"}]
}
